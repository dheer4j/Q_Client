{"ast":null,"code":"/**\n * Utility functions for handling cryptographic operations in the frontend\n * These functions interface with the backend's quantum encryption services\n */\n\n// Convert ArrayBuffer to Base64 string\nexport const arrayBufferToBase64 = buffer => {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n};\n\n// Convert Base64 string to ArrayBuffer\nexport const base64ToArrayBuffer = base64 => {\n  const binaryString = window.atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n};\n\n// Format encryption status for display\nexport const formatEncryptionStatus = status => {\n  return {\n    isActive: status.status === 'active',\n    message: status.message,\n    expiresIn: status.keyExpiresIn,\n    strength: status.keyStrength,\n    color: getStatusColor(status.status)\n  };\n};\n\n// Get color based on encryption status\nexport const getStatusColor = status => {\n  switch (status) {\n    case 'active':\n      return 'green';\n    case 'warning':\n      return 'yellow';\n    case 'expired':\n    case 'inactive':\n      return 'red';\n    default:\n      return 'gray';\n  }\n};\n\n// Format key expiration time\nexport const formatKeyExpiration = expiresInDays => {\n  if (expiresInDays <= 0) {\n    return 'Expired';\n  } else if (expiresInDays === 1) {\n    return 'Expires in 1 day';\n  } else if (expiresInDays < 7) {\n    return `Expires in ${expiresInDays} days`;\n  } else if (expiresInDays < 30) {\n    const weeks = Math.floor(expiresInDays / 7);\n    return `Expires in ${weeks} ${weeks === 1 ? 'week' : 'weeks'}`;\n  } else {\n    const months = Math.floor(expiresInDays / 30);\n    return `Expires in ${months} ${months === 1 ? 'month' : 'months'}`;\n  }\n};\n\n// Calculate encryption strength percentage based on algorithm and key size\nexport const calculateEncryptionStrength = (algorithm, keySize) => {\n  // This is a simplified representation for UI purposes\n  // In reality, encryption strength depends on many factors\n  switch (algorithm.toLowerCase()) {\n    case 'kyber':\n      return keySize >= 1024 ? 95 : 85;\n    case 'ntru':\n      return keySize >= 1024 ? 90 : 80;\n    case 'sike':\n      return keySize >= 1024 ? 85 : 75;\n    case 'dilithium':\n      return keySize >= 1024 ? 92 : 82;\n    default:\n      return 50;\n    // Unknown algorithm\n  }\n};\n\n// Check if an email is encrypted\nexport const isEmailEncrypted = email => {\n  return !!email.isEncrypted;\n};\n\n// Generate a random key for testing purposes\nexport const generateRandomTestKey = () => {\n  const array = new Uint8Array(32);\n  window.crypto.getRandomValues(array);\n  return arrayBufferToBase64(array.buffer);\n};","map":{"version":3,"names":["arrayBufferToBase64","buffer","bytes","Uint8Array","binary","i","byteLength","String","fromCharCode","window","btoa","base64ToArrayBuffer","base64","binaryString","atob","length","charCodeAt","formatEncryptionStatus","status","isActive","message","expiresIn","keyExpiresIn","strength","keyStrength","color","getStatusColor","formatKeyExpiration","expiresInDays","weeks","Math","floor","months","calculateEncryptionStrength","algorithm","keySize","toLowerCase","isEmailEncrypted","email","isEncrypted","generateRandomTestKey","array","crypto","getRandomValues"],"sources":["/Users/siddu/IdeaProjects/Q_client/quantum_email_client/frontend/src/utils/cryptoUtils.ts"],"sourcesContent":["/**\n * Utility functions for handling cryptographic operations in the frontend\n * These functions interface with the backend's quantum encryption services\n */\n\n// Convert ArrayBuffer to Base64 string\nexport const arrayBufferToBase64 = (buffer: ArrayBuffer): string => {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n};\n\n// Convert Base64 string to ArrayBuffer\nexport const base64ToArrayBuffer = (base64: string): ArrayBuffer => {\n  const binaryString = window.atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n};\n\n// Format encryption status for display\nexport const formatEncryptionStatus = (status: {\n  status: string;\n  message: string;\n  keyExpiresIn: string;\n  keyStrength: string;\n}) => {\n  return {\n    isActive: status.status === 'active',\n    message: status.message,\n    expiresIn: status.keyExpiresIn,\n    strength: status.keyStrength,\n    color: getStatusColor(status.status),\n  };\n};\n\n// Get color based on encryption status\nexport const getStatusColor = (status: string): string => {\n  switch (status) {\n    case 'active':\n      return 'green';\n    case 'warning':\n      return 'yellow';\n    case 'expired':\n    case 'inactive':\n      return 'red';\n    default:\n      return 'gray';\n  }\n};\n\n// Format key expiration time\nexport const formatKeyExpiration = (expiresInDays: number): string => {\n  if (expiresInDays <= 0) {\n    return 'Expired';\n  } else if (expiresInDays === 1) {\n    return 'Expires in 1 day';\n  } else if (expiresInDays < 7) {\n    return `Expires in ${expiresInDays} days`;\n  } else if (expiresInDays < 30) {\n    const weeks = Math.floor(expiresInDays / 7);\n    return `Expires in ${weeks} ${weeks === 1 ? 'week' : 'weeks'}`;\n  } else {\n    const months = Math.floor(expiresInDays / 30);\n    return `Expires in ${months} ${months === 1 ? 'month' : 'months'}`;\n  }\n};\n\n// Calculate encryption strength percentage based on algorithm and key size\nexport const calculateEncryptionStrength = (algorithm: string, keySize: number): number => {\n  // This is a simplified representation for UI purposes\n  // In reality, encryption strength depends on many factors\n  switch (algorithm.toLowerCase()) {\n    case 'kyber':\n      return keySize >= 1024 ? 95 : 85;\n    case 'ntru':\n      return keySize >= 1024 ? 90 : 80;\n    case 'sike':\n      return keySize >= 1024 ? 85 : 75;\n    case 'dilithium':\n      return keySize >= 1024 ? 92 : 82;\n    default:\n      return 50; // Unknown algorithm\n  }\n};\n\n// Check if an email is encrypted\nexport const isEmailEncrypted = (email: any): boolean => {\n  return !!email.isEncrypted;\n};\n\n// Generate a random key for testing purposes\nexport const generateRandomTestKey = (): string => {\n  const array = new Uint8Array(32);\n  window.crypto.getRandomValues(array);\n  return arrayBufferToBase64(array.buffer);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}