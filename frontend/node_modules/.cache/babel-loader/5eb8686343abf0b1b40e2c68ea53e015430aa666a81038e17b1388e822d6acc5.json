{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nexport const useEmailManagement = () => {\n  _s();\n  const [emails, setEmails] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const fetchEmails = async () => {\n      try {\n        // In a real app, this would make an API call to fetch emails\n        // For demo purposes, we'll use mock data\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        const mockEmails = [{\n          id: '1',\n          sender: 'alice@example.com',\n          recipient: 'bob@example.com',\n          subject: 'Quantum Key Exchange Protocol',\n          content: 'I\\'ve implemented the new quantum key exchange protocol. Let\\'s discuss its security features in our next meeting.',\n          timestamp: '2025-03-25T08:30:00',\n          isRead: true,\n          isEncrypted: true,\n          labels: ['important', 'work']\n        }, {\n          id: '2',\n          sender: 'security@quantumsafe.org',\n          recipient: 'bob@example.com',\n          subject: 'Security Alert: New Quantum-Safe Standards',\n          content: 'The National Institute of Standards and Technology (NIST) has published new guidelines for post-quantum cryptography. Please review the attached document.',\n          timestamp: '2025-03-24T14:15:00',\n          isRead: false,\n          isEncrypted: true,\n          labels: ['important', 'security']\n        }, {\n          id: '3',\n          sender: 'team@newsletter.dev',\n          recipient: 'bob@example.com',\n          subject: 'Weekly Developer Newsletter',\n          content: 'This week in tech: Quantum computing breakthroughs, new JavaScript frameworks, and more!',\n          timestamp: '2025-03-23T09:45:00',\n          isRead: true,\n          isEncrypted: false,\n          labels: ['newsletter']\n        }, {\n          id: '4',\n          sender: 'charlie@research.edu',\n          recipient: 'bob@example.com',\n          subject: 'Research Collaboration Opportunity',\n          content: 'We\\'re working on a new quantum-resistant algorithm and would love your input. Are you available for a call next week?',\n          timestamp: '2025-03-22T16:20:00',\n          isRead: false,\n          isEncrypted: true,\n          labels: ['work', 'research']\n        }, {\n          id: '5',\n          sender: 'events@conference.org',\n          recipient: 'bob@example.com',\n          subject: 'Invitation: Quantum Computing Summit',\n          content: 'You\\'re invited to speak at the annual Quantum Computing Summit. Please let us know if you\\'re available on May 15-17.',\n          timestamp: '2025-03-21T11:10:00',\n          isRead: true,\n          isEncrypted: false,\n          labels: ['event']\n        }];\n        setEmails(mockEmails);\n        setLoading(false);\n      } catch (err) {\n        console.error('Failed to fetch emails:', err);\n        setError(err.message || 'Failed to fetch emails');\n        setLoading(false);\n      }\n    };\n    fetchEmails();\n  }, []);\n  const sendEmail = async emailData => {\n    try {\n      // In a real app, this would make an API call to send the email\n      // For demo purposes, we'll simulate sending\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      const newEmail = {\n        ...emailData,\n        id: Date.now().toString(),\n        timestamp: new Date().toISOString(),\n        isRead: true\n      };\n      setEmails(prev => [newEmail, ...prev]);\n      return newEmail.id;\n    } catch (err) {\n      console.error('Failed to send email:', err);\n      throw new Error(err.message || 'Failed to send email');\n    }\n  };\n  const markAsRead = async emailId => {\n    try {\n      // In a real app, this would make an API call to update the email\n      // For demo purposes, we'll update the local state\n      setEmails(prev => prev.map(email => email.id === emailId ? {\n        ...email,\n        isRead: true\n      } : email));\n    } catch (err) {\n      console.error('Failed to mark email as read:', err);\n      throw new Error(err.message || 'Failed to mark email as read');\n    }\n  };\n  const deleteEmail = async emailId => {\n    try {\n      // In a real app, this would make an API call to delete the email\n      // For demo purposes, we'll update the local state\n      setEmails(prev => prev.filter(email => email.id !== emailId));\n    } catch (err) {\n      console.error('Failed to delete email:', err);\n      throw new Error(err.message || 'Failed to delete email');\n    }\n  };\n  return {\n    emails,\n    loading,\n    error,\n    sendEmail,\n    markAsRead,\n    deleteEmail\n  };\n};\n_s(useEmailManagement, \"Euylchhn8zQbWsS8EhOkKL+D2kk=\");\nexport default useEmailManagement;","map":{"version":3,"names":["useState","useEffect","useEmailManagement","_s","emails","setEmails","loading","setLoading","error","setError","fetchEmails","Promise","resolve","setTimeout","mockEmails","id","sender","recipient","subject","content","timestamp","isRead","isEncrypted","labels","err","console","message","sendEmail","emailData","newEmail","Date","now","toString","toISOString","prev","Error","markAsRead","emailId","map","email","deleteEmail","filter"],"sources":["/Users/siddu/IdeaProjects/Q_client/quantum_email_client/frontend/src/hooks/useEmailManagement.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\n\ninterface Email {\n  id: string;\n  sender: string;\n  recipient: string;\n  subject: string;\n  content: string;\n  timestamp: string;\n  isRead: boolean;\n  isEncrypted: boolean;\n  attachments?: string[];\n  labels?: string[];\n}\n\nexport const useEmailManagement = () => {\n  const [emails, setEmails] = useState<Email[]>([]);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchEmails = async () => {\n      try {\n        // In a real app, this would make an API call to fetch emails\n        // For demo purposes, we'll use mock data\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        \n        const mockEmails: Email[] = [\n          {\n            id: '1',\n            sender: 'alice@example.com',\n            recipient: 'bob@example.com',\n            subject: 'Quantum Key Exchange Protocol',\n            content: 'I\\'ve implemented the new quantum key exchange protocol. Let\\'s discuss its security features in our next meeting.',\n            timestamp: '2025-03-25T08:30:00',\n            isRead: true,\n            isEncrypted: true,\n            labels: ['important', 'work']\n          },\n          {\n            id: '2',\n            sender: 'security@quantumsafe.org',\n            recipient: 'bob@example.com',\n            subject: 'Security Alert: New Quantum-Safe Standards',\n            content: 'The National Institute of Standards and Technology (NIST) has published new guidelines for post-quantum cryptography. Please review the attached document.',\n            timestamp: '2025-03-24T14:15:00',\n            isRead: false,\n            isEncrypted: true,\n            labels: ['important', 'security']\n          },\n          {\n            id: '3',\n            sender: 'team@newsletter.dev',\n            recipient: 'bob@example.com',\n            subject: 'Weekly Developer Newsletter',\n            content: 'This week in tech: Quantum computing breakthroughs, new JavaScript frameworks, and more!',\n            timestamp: '2025-03-23T09:45:00',\n            isRead: true,\n            isEncrypted: false,\n            labels: ['newsletter']\n          },\n          {\n            id: '4',\n            sender: 'charlie@research.edu',\n            recipient: 'bob@example.com',\n            subject: 'Research Collaboration Opportunity',\n            content: 'We\\'re working on a new quantum-resistant algorithm and would love your input. Are you available for a call next week?',\n            timestamp: '2025-03-22T16:20:00',\n            isRead: false,\n            isEncrypted: true,\n            labels: ['work', 'research']\n          },\n          {\n            id: '5',\n            sender: 'events@conference.org',\n            recipient: 'bob@example.com',\n            subject: 'Invitation: Quantum Computing Summit',\n            content: 'You\\'re invited to speak at the annual Quantum Computing Summit. Please let us know if you\\'re available on May 15-17.',\n            timestamp: '2025-03-21T11:10:00',\n            isRead: true,\n            isEncrypted: false,\n            labels: ['event']\n          }\n        ];\n        \n        setEmails(mockEmails);\n        setLoading(false);\n      } catch (err: any) {\n        console.error('Failed to fetch emails:', err);\n        setError(err.message || 'Failed to fetch emails');\n        setLoading(false);\n      }\n    };\n\n    fetchEmails();\n  }, []);\n\n  const sendEmail = async (emailData: Omit<Email, 'id' | 'timestamp' | 'isRead'>) => {\n    try {\n      // In a real app, this would make an API call to send the email\n      // For demo purposes, we'll simulate sending\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      const newEmail: Email = {\n        ...emailData,\n        id: Date.now().toString(),\n        timestamp: new Date().toISOString(),\n        isRead: true\n      };\n      \n      setEmails(prev => [newEmail, ...prev]);\n      return newEmail.id;\n    } catch (err: any) {\n      console.error('Failed to send email:', err);\n      throw new Error(err.message || 'Failed to send email');\n    }\n  };\n\n  const markAsRead = async (emailId: string) => {\n    try {\n      // In a real app, this would make an API call to update the email\n      // For demo purposes, we'll update the local state\n      setEmails(prev => \n        prev.map(email => \n          email.id === emailId ? { ...email, isRead: true } : email\n        )\n      );\n    } catch (err: any) {\n      console.error('Failed to mark email as read:', err);\n      throw new Error(err.message || 'Failed to mark email as read');\n    }\n  };\n\n  const deleteEmail = async (emailId: string) => {\n    try {\n      // In a real app, this would make an API call to delete the email\n      // For demo purposes, we'll update the local state\n      setEmails(prev => prev.filter(email => email.id !== emailId));\n    } catch (err: any) {\n      console.error('Failed to delete email:', err);\n      throw new Error(err.message || 'Failed to delete email');\n    }\n  };\n\n  return {\n    emails,\n    loading,\n    error,\n    sendEmail,\n    markAsRead,\n    deleteEmail\n  };\n};\n\nexport default useEmailManagement;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}