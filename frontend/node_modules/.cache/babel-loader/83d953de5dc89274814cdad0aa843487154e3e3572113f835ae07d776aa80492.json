{"ast":null,"code":"var _jsxFileName = \"/Users/siddu/IdeaProjects/Q_client/quantum_email_client/frontend/src/hooks/useEncryption.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useState, useEffect, createContext, useContext } from 'react';\nimport { useAuth } from './useAuth';\nimport { useWebSocket } from './useWebSocket';\nimport { generateQuantumKeyPair as apiGenerateKeyPair, completeKeyExchange as apiCompleteKeyExchange, getEncryptionStatus as apiGetEncryptionStatus, encryptEmail as apiEncryptEmail, decryptEmail as apiDecryptEmail } from '../services/encryptionService';\nimport { calculateEncryptionStrength } from '../utils/cryptoUtils';\nimport { createEncryptionStatusMessage } from '../utils/webSocketUtils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Create context with default values\nexport const EncryptionContext = /*#__PURE__*/createContext({\n  encryptionStatus: null,\n  encryptEmail: async () => ({\n    encryptedContent: '',\n    encryptedSharedSecret: ''\n  }),\n  decryptEmail: async () => '',\n  generateQuantumKeyPair: async () => {},\n  completeKeyExchange: async () => {},\n  rotateKeys: async () => {},\n  encryptionStrength: 0\n});\n// Provider component\nexport const EncryptionProvider = ({\n  children\n}) => {\n  _s();\n  const [encryptionStatus, setEncryptionStatus] = useState(null);\n  const [encryptionStrength, setEncryptionStrength] = useState(0);\n  const {\n    user\n  } = useAuth();\n  const {\n    sendMessage\n  } = useWebSocket(`ws://localhost:8080/ws${user !== null && user !== void 0 && user.id ? `?user_id=${user.id}` : ''}`);\n\n  // Check encryption status on mount and when user changes\n  useEffect(() => {\n    const checkEncryptionStatus = async () => {\n      try {\n        if (!user) {\n          setEncryptionStatus({\n            status: 'inactive',\n            message: 'Please log in to use encryption'\n          });\n          return;\n        }\n        const statusData = await apiGetEncryptionStatus();\n        setEncryptionStatus(statusData);\n\n        // Calculate encryption strength based on algorithm and key size\n        if (statusData.algorithm && statusData.keySize) {\n          const strength = calculateEncryptionStrength(statusData.algorithm, statusData.keySize);\n          setEncryptionStrength(strength);\n        }\n      } catch (err) {\n        console.error('Failed to check encryption status:', err);\n        setEncryptionStatus({\n          status: 'error',\n          message: 'Encryption status check failed: ' + (err.message || 'Unknown error')\n        });\n      }\n    };\n    checkEncryptionStatus();\n\n    // Set up interval to periodically check encryption status\n    const intervalId = setInterval(checkEncryptionStatus, 5 * 60 * 1000); // Check every 5 minutes\n\n    return () => clearInterval(intervalId);\n  }, [user]);\n  const encryptEmail = async emailData => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n      if (!encryptionStatus || encryptionStatus.status !== 'active') {\n        throw new Error('Encryption is not active');\n      }\n      const result = await apiEncryptEmail(emailData);\n      return {\n        encryptedContent: result.encryptedContent,\n        encryptedSharedSecret: result.encryptedSharedSecret\n      };\n    } catch (err) {\n      console.error('Encryption failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Encryption failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n  const decryptEmail = async (emailId, encryptedContent, encryptedSharedSecret) => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n      if (!encryptionStatus || encryptionStatus.status !== 'active') {\n        throw new Error('Encryption is not active');\n      }\n      const result = await apiDecryptEmail(emailId, encryptedContent, encryptedSharedSecret);\n      return result;\n    } catch (err) {\n      console.error('Decryption failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Decryption failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n  const generateQuantumKeyPair = async () => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n      const result = await apiGenerateKeyPair();\n\n      // Update encryption status\n      setEncryptionStatus({\n        status: 'active',\n        message: 'New quantum keys generated',\n        keyExpiresIn: result.expiresIn,\n        keyStrength: result.strength,\n        algorithm: result.algorithm,\n        keySize: result.keySize\n      });\n\n      // Calculate and update encryption strength\n      if (result.algorithm && result.keySize) {\n        const strength = calculateEncryptionStrength(result.algorithm, result.keySize);\n        setEncryptionStrength(strength);\n      }\n\n      // Notify other clients via WebSocket\n      if (user.id) {\n        sendMessage(createEncryptionStatusMessage(user.id, 'key_generated', {\n          keyId: result.keyId,\n          expiresIn: result.expiresIn\n        }));\n      }\n    } catch (err) {\n      console.error('Key generation failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Key generation failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n  const completeKeyExchange = async () => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n      const result = await apiCompleteKeyExchange();\n\n      // Update encryption status\n      setEncryptionStatus({\n        status: 'active',\n        message: 'Quantum key exchange complete',\n        keyExpiresIn: result.expiresIn,\n        keyStrength: result.strength,\n        algorithm: result.algorithm,\n        keySize: result.keySize\n      });\n\n      // Calculate and update encryption strength\n      if (result.algorithm && result.keySize) {\n        const strength = calculateEncryptionStrength(result.algorithm, result.keySize);\n        setEncryptionStrength(strength);\n      }\n\n      // Notify other clients via WebSocket\n      if (user.id) {\n        sendMessage(createEncryptionStatusMessage(user.id, 'key_exchange_complete', {\n          keyId: result.keyId,\n          expiresIn: result.expiresIn\n        }));\n      }\n    } catch (err) {\n      console.error('Key exchange failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Key exchange failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n  const rotateKeys = async () => {\n    try {\n      // First generate new keys\n      await generateQuantumKeyPair();\n\n      // Then complete the key exchange\n      await completeKeyExchange();\n\n      // Update encryption status\n      setEncryptionStatus(prev => {\n        if (!prev) return prev;\n        return {\n          ...prev,\n          message: 'Quantum keys rotated successfully'\n        };\n      });\n\n      // Notify other clients via WebSocket\n      if (user !== null && user !== void 0 && user.id) {\n        sendMessage(createEncryptionStatusMessage(user.id, 'key_rotated', {\n          timestamp: new Date().toISOString()\n        }));\n      }\n    } catch (err) {\n      console.error('Key rotation failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Key rotation failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n  const value = {\n    encryptionStatus,\n    encryptEmail,\n    decryptEmail,\n    generateQuantumKeyPair,\n    completeKeyExchange,\n    rotateKeys,\n    encryptionStrength\n  };\n  return /*#__PURE__*/_jsxDEV(EncryptionContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 265,\n    columnNumber: 10\n  }, this);\n};\n\n// Custom hook to use the encryption context\n_s(EncryptionProvider, \"s492FHCA0TQXU+gVpJnwlHeBO1Q=\", false, function () {\n  return [useAuth, useWebSocket];\n});\n_c = EncryptionProvider;\nexport const useEncryption = () => {\n  _s2();\n  const context = useContext(EncryptionContext);\n  if (!context) {\n    throw new Error('useEncryption must be used within an EncryptionProvider');\n  }\n  return context;\n};\n_s2(useEncryption, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default useEncryption;\nvar _c;\n$RefreshReg$(_c, \"EncryptionProvider\");","map":{"version":3,"names":["React","useState","useEffect","createContext","useContext","useAuth","useWebSocket","generateQuantumKeyPair","apiGenerateKeyPair","completeKeyExchange","apiCompleteKeyExchange","getEncryptionStatus","apiGetEncryptionStatus","encryptEmail","apiEncryptEmail","decryptEmail","apiDecryptEmail","calculateEncryptionStrength","createEncryptionStatusMessage","jsxDEV","_jsxDEV","EncryptionContext","encryptionStatus","encryptedContent","encryptedSharedSecret","rotateKeys","encryptionStrength","EncryptionProvider","children","_s","setEncryptionStatus","setEncryptionStrength","user","sendMessage","id","checkEncryptionStatus","status","message","statusData","algorithm","keySize","strength","err","console","error","intervalId","setInterval","clearInterval","emailData","Error","result","emailId","keyExpiresIn","expiresIn","keyStrength","keyId","prev","timestamp","Date","toISOString","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useEncryption","_s2","context","$RefreshReg$"],"sources":["/Users/siddu/IdeaProjects/Q_client/quantum_email_client/frontend/src/hooks/useEncryption.tsx"],"sourcesContent":["import React, { useState, useEffect, createContext, useContext } from 'react';\nimport { useAuth } from './useAuth';\nimport { useWebSocket } from './useWebSocket';\nimport { \n  generateQuantumKeyPair as apiGenerateKeyPair,\n  completeKeyExchange as apiCompleteKeyExchange,\n  getEncryptionStatus as apiGetEncryptionStatus,\n  encryptEmail as apiEncryptEmail,\n  decryptEmail as apiDecryptEmail\n} from '../services/encryptionService';\nimport { formatEncryptionStatus, calculateEncryptionStrength } from '../utils/cryptoUtils';\nimport { createEncryptionStatusMessage } from '../utils/webSocketUtils';\n\ninterface EncryptionStatus {\n  status: 'active' | 'warning' | 'error' | 'inactive';\n  message: string;\n  keyExpiresIn?: string;\n  keyStrength?: string;\n  algorithm?: string;\n  keySize?: number;\n}\n\ninterface EncryptionContextType {\n  encryptionStatus: EncryptionStatus | null;\n  encryptEmail: (emailData: any) => Promise<{ encryptedContent: string, encryptedSharedSecret: string }>;\n  decryptEmail: (emailId: string, encryptedContent: string, encryptedSharedSecret: string) => Promise<string>;\n  generateQuantumKeyPair: () => Promise<void>;\n  completeKeyExchange: () => Promise<void>;\n  rotateKeys: () => Promise<void>;\n  encryptionStrength: number;\n}\n\n// Create context with default values\nexport const EncryptionContext = createContext<EncryptionContextType>({\n  encryptionStatus: null,\n  encryptEmail: async () => ({ encryptedContent: '', encryptedSharedSecret: '' }),\n  decryptEmail: async () => '',\n  generateQuantumKeyPair: async () => {},\n  completeKeyExchange: async () => {},\n  rotateKeys: async () => {},\n  encryptionStrength: 0\n});\n\ninterface EncryptionProviderProps {\n  children: React.ReactNode;\n}\n\n// Provider component\nexport const EncryptionProvider: React.FC<EncryptionProviderProps> = ({ children }) => {\n  const [encryptionStatus, setEncryptionStatus] = useState<EncryptionStatus | null>(null);\n  const [encryptionStrength, setEncryptionStrength] = useState<number>(0);\n  const { user } = useAuth();\n  const { sendMessage } = useWebSocket(`ws://localhost:8080/ws${user?.id ? `?user_id=${user.id}` : ''}`);\n\n  // Check encryption status on mount and when user changes\n  useEffect(() => {\n    const checkEncryptionStatus = async () => {\n      try {\n        if (!user) {\n          setEncryptionStatus({\n            status: 'inactive',\n            message: 'Please log in to use encryption'\n          });\n          return;\n        }\n\n        const statusData = await apiGetEncryptionStatus();\n        setEncryptionStatus(statusData);\n        \n        // Calculate encryption strength based on algorithm and key size\n        if (statusData.algorithm && statusData.keySize) {\n          const strength = calculateEncryptionStrength(statusData.algorithm, statusData.keySize);\n          setEncryptionStrength(strength);\n        }\n      } catch (err: any) {\n        console.error('Failed to check encryption status:', err);\n        setEncryptionStatus({\n          status: 'error',\n          message: 'Encryption status check failed: ' + (err.message || 'Unknown error')\n        });\n      }\n    };\n\n    checkEncryptionStatus();\n    \n    // Set up interval to periodically check encryption status\n    const intervalId = setInterval(checkEncryptionStatus, 5 * 60 * 1000); // Check every 5 minutes\n    \n    return () => clearInterval(intervalId);\n  }, [user]);\n\n  const encryptEmail = async (emailData: any): Promise<{ encryptedContent: string, encryptedSharedSecret: string }> => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n      \n      if (!encryptionStatus || encryptionStatus.status !== 'active') {\n        throw new Error('Encryption is not active');\n      }\n\n      const result = await apiEncryptEmail(emailData);\n      \n      return {\n        encryptedContent: result.encryptedContent,\n        encryptedSharedSecret: result.encryptedSharedSecret\n      };\n    } catch (err: any) {\n      console.error('Encryption failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Encryption failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n\n  const decryptEmail = async (emailId: string, encryptedContent: string, encryptedSharedSecret: string): Promise<string> => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n      \n      if (!encryptionStatus || encryptionStatus.status !== 'active') {\n        throw new Error('Encryption is not active');\n      }\n\n      const result = await apiDecryptEmail(emailId, encryptedContent, encryptedSharedSecret);\n      return result;\n    } catch (err: any) {\n      console.error('Decryption failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Decryption failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n\n  const generateQuantumKeyPair = async (): Promise<void> => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n\n      const result = await apiGenerateKeyPair();\n      \n      // Update encryption status\n      setEncryptionStatus({\n        status: 'active',\n        message: 'New quantum keys generated',\n        keyExpiresIn: result.expiresIn,\n        keyStrength: result.strength,\n        algorithm: result.algorithm,\n        keySize: result.keySize\n      });\n      \n      // Calculate and update encryption strength\n      if (result.algorithm && result.keySize) {\n        const strength = calculateEncryptionStrength(result.algorithm, result.keySize);\n        setEncryptionStrength(strength);\n      }\n      \n      // Notify other clients via WebSocket\n      if (user.id) {\n        sendMessage(createEncryptionStatusMessage(user.id, 'key_generated', {\n          keyId: result.keyId,\n          expiresIn: result.expiresIn\n        }));\n      }\n    } catch (err: any) {\n      console.error('Key generation failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Key generation failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n\n  const completeKeyExchange = async (): Promise<void> => {\n    try {\n      if (!user) {\n        throw new Error('User not authenticated');\n      }\n\n      const result = await apiCompleteKeyExchange();\n      \n      // Update encryption status\n      setEncryptionStatus({\n        status: 'active',\n        message: 'Quantum key exchange complete',\n        keyExpiresIn: result.expiresIn,\n        keyStrength: result.strength,\n        algorithm: result.algorithm,\n        keySize: result.keySize\n      });\n      \n      // Calculate and update encryption strength\n      if (result.algorithm && result.keySize) {\n        const strength = calculateEncryptionStrength(result.algorithm, result.keySize);\n        setEncryptionStrength(strength);\n      }\n      \n      // Notify other clients via WebSocket\n      if (user.id) {\n        sendMessage(createEncryptionStatusMessage(user.id, 'key_exchange_complete', {\n          keyId: result.keyId,\n          expiresIn: result.expiresIn\n        }));\n      }\n    } catch (err: any) {\n      console.error('Key exchange failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Key exchange failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n  \n  const rotateKeys = async (): Promise<void> => {\n    try {\n      // First generate new keys\n      await generateQuantumKeyPair();\n      \n      // Then complete the key exchange\n      await completeKeyExchange();\n      \n      // Update encryption status\n      setEncryptionStatus(prev => {\n        if (!prev) return prev;\n        return {\n          ...prev,\n          message: 'Quantum keys rotated successfully'\n        };\n      });\n      \n      // Notify other clients via WebSocket\n      if (user?.id) {\n        sendMessage(createEncryptionStatusMessage(user.id, 'key_rotated', {\n          timestamp: new Date().toISOString()\n        }));\n      }\n    } catch (err: any) {\n      console.error('Key rotation failed:', err);\n      setEncryptionStatus({\n        status: 'error',\n        message: 'Key rotation failed: ' + (err.message || 'Unknown error')\n      });\n      throw err;\n    }\n  };\n\n  const value = {\n    encryptionStatus,\n    encryptEmail,\n    decryptEmail,\n    generateQuantumKeyPair,\n    completeKeyExchange,\n    rotateKeys,\n    encryptionStrength\n  };\n\n  return <EncryptionContext.Provider value={value}>{children}</EncryptionContext.Provider>;\n};\n\n// Custom hook to use the encryption context\nexport const useEncryption = (): EncryptionContextType => {\n  const context = useContext(EncryptionContext);\n  \n  if (!context) {\n    throw new Error('useEncryption must be used within an EncryptionProvider');\n  }\n  \n  return context;\n};\n\nexport default useEncryption;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}