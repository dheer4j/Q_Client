{"ast":null,"code":"import axios from 'axios';\n\n// Use a constant for the API URL since we're in development mode\nconst API_URL = 'http://localhost:8080/api';\n\n// Generate a new quantum-resistant key pair\nexport const generateQuantumKeyPair = async () => {\n  try {\n    const token = localStorage.getItem('authToken');\n    const response = await axios.post(`${API_URL}/encryption/generate-key-pair`, {}, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to generate key pair');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Complete the key exchange process with the server\nexport const completeKeyExchange = async () => {\n  try {\n    const token = localStorage.getItem('authToken');\n    const response = await axios.post(`${API_URL}/encryption/complete-key-exchange`, {}, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to complete key exchange');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Get the current encryption status\nexport const getEncryptionStatus = async () => {\n  try {\n    const token = localStorage.getItem('authToken');\n    const response = await axios.get(`${API_URL}/encryption/status`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to get encryption status');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Encrypt email content\nexport const encryptEmail = async emailData => {\n  try {\n    const token = localStorage.getItem('authToken');\n    const response = await axios.post(`${API_URL}/encryption/encrypt`, emailData, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to encrypt email');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Decrypt email content\nexport const decryptEmail = async (emailId, encryptedContent, encryptedSharedSecret) => {\n  try {\n    const token = localStorage.getItem('authToken');\n    const response = await axios.post(`${API_URL}/encryption/decrypt`, {\n      emailId,\n      encryptedContent,\n      encryptedSharedSecret\n    }, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    return response.data.content;\n  } catch (error) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to decrypt email');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// For demo/testing purposes\nexport const mockEncryptionStatus = () => {\n  return {\n    status: 'active',\n    message: 'Quantum encryption active',\n    keyExpiresIn: '29 days',\n    keyStrength: 'high'\n  };\n};","map":{"version":3,"names":["axios","API_URL","generateQuantumKeyPair","token","localStorage","getItem","response","post","headers","Authorization","data","error","Error","message","completeKeyExchange","getEncryptionStatus","get","encryptEmail","emailData","decryptEmail","emailId","encryptedContent","encryptedSharedSecret","content","mockEncryptionStatus","status","keyExpiresIn","keyStrength"],"sources":["/Users/siddu/IdeaProjects/Q_client/quantum_email_client/frontend/src/services/encryptionService.ts"],"sourcesContent":["import axios from 'axios';\n\n// Use a constant for the API URL since we're in development mode\nconst API_URL = 'http://localhost:8080/api';\n\n// Generate a new quantum-resistant key pair\nexport const generateQuantumKeyPair = async () => {\n  try {\n    const token = localStorage.getItem('authToken');\n    \n    const response = await axios.post(\n      `${API_URL}/encryption/generate-key-pair`,\n      {},\n      {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      }\n    );\n    \n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to generate key pair');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Complete the key exchange process with the server\nexport const completeKeyExchange = async () => {\n  try {\n    const token = localStorage.getItem('authToken');\n    \n    const response = await axios.post(\n      `${API_URL}/encryption/complete-key-exchange`,\n      {},\n      {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      }\n    );\n    \n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to complete key exchange');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Get the current encryption status\nexport const getEncryptionStatus = async () => {\n  try {\n    const token = localStorage.getItem('authToken');\n    \n    const response = await axios.get(\n      `${API_URL}/encryption/status`,\n      {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      }\n    );\n    \n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to get encryption status');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Encrypt email content\nexport const encryptEmail = async (emailData: any) => {\n  try {\n    const token = localStorage.getItem('authToken');\n    \n    const response = await axios.post(\n      `${API_URL}/encryption/encrypt`,\n      emailData,\n      {\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n    \n    return response.data;\n  } catch (error: any) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to encrypt email');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// Decrypt email content\nexport const decryptEmail = async (emailId: string, encryptedContent: string, encryptedSharedSecret: string) => {\n  try {\n    const token = localStorage.getItem('authToken');\n    \n    const response = await axios.post(\n      `${API_URL}/encryption/decrypt`,\n      { \n        emailId,\n        encryptedContent,\n        encryptedSharedSecret \n      },\n      {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      }\n    );\n    \n    return response.data.content;\n  } catch (error: any) {\n    if (error.response) {\n      throw new Error(error.response.data.message || 'Failed to decrypt email');\n    }\n    throw new Error('Network error. Please try again.');\n  }\n};\n\n// For demo/testing purposes\nexport const mockEncryptionStatus = () => {\n  return {\n    status: 'active',\n    message: 'Quantum encryption active',\n    keyExpiresIn: '29 days',\n    keyStrength: 'high'\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}